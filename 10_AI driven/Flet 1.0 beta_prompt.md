
```

## 0. 目的
あなたは熟練のソフトウェアエンジニアです。
Flet 1.0 beta の宣言的UI（UI = f(state)）で {APP_NAME} を実装してください。
要件を満たす「最小の動くプロダクト(MVP)」を最優先し、次に拡張性（将来の機能追加）を確保してください。 参考：Flet 1.0 beta は @ft.component / Hooks / observable / reducer(dispatch) が重要です。

## 1. 成果物（必須）
- 実装コード一式（Fletアプリ）
- 実行手順（uv / flet コマンド、環境変数があればそれも）
- テスト（可能な範囲で：ユニット or 最低限の動作確認手順）
- 変更点の要約（ファイル単位で箇条書き）
- セキュリティ/品質セルフレビュー（指摘→修正まで）

## 2. 機能要件（差し替え）
{FEATURES}
例：
- Todoの追加/完了/削除
- ローカル保存（ファイル or SQLite）※副作用は use_effect に隔離
- フィルタ（All/Active/Done）
- エラー時はユーザー向けメッセージ、内部情報は出さない

## 3. 非機能要件（厳守）
### 3.1 セキュリティ
- 生成したコードは「信頼できない」前提で、安全側に倒すこと。
- 入力検証：UI入力も含めてバリデーション（型、長さ、許容文字、空値）。
- 依存は最小。追加依存が必要なら理由・代替案・ライセンスを明記。
- 例外・ログ：機密情報を出さない。ユーザーには簡潔なエラー表示。
- 外部I/O（ファイル/DB/API）は use_effect に隔離し、失敗時の復旧策を用意。
- 危険な実行（eval/exec/任意コード実行）は禁止。

### 3.2 品質
- 責務分離：UI / 状態管理 / 永続化 / ドメインを分ける（過剰分割はしない）。
- 後で reducer/dispatch（Redux風）に移行できるよう、状態の境界を明確に。
- 変更容易性：拡張は「追加」で済む設計を目指す（既存改変を最小化）。

## 4. 技術方針（Flet 1.0 beta 前提）
- UIは @ft.component で関数コンポーネント化する。
- 状態はまず以下のいずれかで実装（判断して採用理由を書く）：
  A) @ft.observable な Store（MobX/Zustand的）
  B) reducer/dispatch（Redux風。追跡性とテスト性重視）
- 副作用（保存・I/O・タイマー等）は use_effect に隔離する。
- タスク/ハンドル等、再描画に影響させたくない保持は use_ref を使う。
- 可能なら Context（create_context / use_context）で設定やサービスを配布する。

## 5. 作業手順（この順で進める）
Step 1) 要件を1ページで要約し、画面構成（コンポーネント分割案）と状態設計を提案。
Step 2) ディレクトリ構成案を提示（例：ui/, store/, services/, domain/）。
Step 3) 実装（まず動かす → リファクタの順）。page.update() に依存しない設計にする。
Step 4) 自己レビュー（脆弱性・例外・依存・境界条件）。問題があれば修正してから提示。
Step 5) テスト or 最低限の動作確認手順を用意し、再現できる形で書く。

## 6. 実行環境メモ（必要なら利用）
- インストール：uv add flet  または uv add flet[all]
- 雛形：flet create .
- 起動：{RUN_COMMAND}
（実際のプロジェクト構成に合わせて最適化してよいが、コマンドは必ず明記）

## 7. 出力形式（厳守）
- まず「設計提案」を短く出す
- 次に「差分（ファイルごと）」→「コード」→「実行手順」→「自己レビュー結果」
- 省略せず、コピペで動かせる状態にする
  ```
